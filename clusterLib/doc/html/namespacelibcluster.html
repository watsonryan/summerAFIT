<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libcluster: libcluster Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libcluster
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacelibcluster.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">libcluster Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace that contains implementations of Bayesian mixture model based algorithms for clustering.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3e50a4ac1b9e897150bb3b66d3dbf1e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e50a4ac1b9e897150bb3b66d3dbf1e7"></a>
typedef std::vector&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a></td></tr>
<tr class="memdesc:a3e50a4ac1b9e897150bb3b66d3dbf1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of double matricies. <br /></td></tr>
<tr class="separator:a3e50a4ac1b9e897150bb3b66d3dbf1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59610bea91daa45fe7c8e3781e467148"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59610bea91daa45fe7c8e3781e467148"></a>
typedef std::vector&lt; std::vector&lt; Eigen::MatrixXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#a59610bea91daa45fe7c8e3781e467148">vvMatrixXd</a></td></tr>
<tr class="memdesc:a59610bea91daa45fe7c8e3781e467148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of vectors of double matricies. <br /></td></tr>
<tr class="separator:a59610bea91daa45fe7c8e3781e467148"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0fbb77cd8728a6fc433153eddedea0ce"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#a0fbb77cd8728a6fc433153eddedea0ce">learnVDP</a> (const Eigen::MatrixXd &amp;X, Eigen::MatrixXd &amp;qZ, <a class="el" href="classdistributions_1_1_stick_break.html">distributions::StickBreak</a> &amp;weights, std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;clusters, const double clusterprior=<a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a>, const int maxclusters=-1, const bool verbose=false, const unsigned int nthreads=omp_get_max_threads())</td></tr>
<tr class="memdesc:a0fbb77cd8728a6fc433153eddedea0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The learning algorithm for the Variational Dirichlet Process for Gaussian clusters.  <a href="#a0fbb77cd8728a6fc433153eddedea0ce">More...</a><br /></td></tr>
<tr class="separator:a0fbb77cd8728a6fc433153eddedea0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8a1e813c9b99a64d25e0edca9eabc1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#adf8a1e813c9b99a64d25e0edca9eabc1">learnBGMM</a> (const Eigen::MatrixXd &amp;X, Eigen::MatrixXd &amp;qZ, <a class="el" href="classdistributions_1_1_dirichlet.html">distributions::Dirichlet</a> &amp;weights, std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;clusters, const double clusterprior=<a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a>, const int maxclusters=-1, const bool verbose=false, const unsigned int nthreads=omp_get_max_threads())</td></tr>
<tr class="memdesc:adf8a1e813c9b99a64d25e0edca9eabc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The learning algorithm for a Bayesian Gaussian Mixture model.  <a href="#adf8a1e813c9b99a64d25e0edca9eabc1">More...</a><br /></td></tr>
<tr class="separator:adf8a1e813c9b99a64d25e0edca9eabc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6eaa1e8eca76f44ee1beb02a12681c5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#af6eaa1e8eca76f44ee1beb02a12681c5">learnDGMM</a> (const Eigen::MatrixXd &amp;X, Eigen::MatrixXd &amp;qZ, <a class="el" href="classdistributions_1_1_dirichlet.html">distributions::Dirichlet</a> &amp;weights, std::vector&lt; <a class="el" href="classdistributions_1_1_norm_gamma.html">distributions::NormGamma</a> &gt; &amp;clusters, const double clusterprior=<a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a>, const int maxclusters=-1, const bool verbose=false, const unsigned int nthreads=omp_get_max_threads())</td></tr>
<tr class="memdesc:af6eaa1e8eca76f44ee1beb02a12681c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The learning algorithm for a Bayesian Gaussian Mixture model with diagonal covariance matrices.  <a href="#af6eaa1e8eca76f44ee1beb02a12681c5">More...</a><br /></td></tr>
<tr class="separator:af6eaa1e8eca76f44ee1beb02a12681c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ca3b7795cfca37cae992679f3941e4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#a32ca3b7795cfca37cae992679f3941e4">learnBEMM</a> (const Eigen::MatrixXd &amp;X, Eigen::MatrixXd &amp;qZ, <a class="el" href="classdistributions_1_1_dirichlet.html">distributions::Dirichlet</a> &amp;weights, std::vector&lt; <a class="el" href="classdistributions_1_1_exp_gamma.html">distributions::ExpGamma</a> &gt; &amp;clusters, const double clusterprior=<a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a>, const int maxclusters=-1, const bool verbose=false, const unsigned int nthreads=omp_get_max_threads())</td></tr>
<tr class="memdesc:a32ca3b7795cfca37cae992679f3941e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The learning algorithm for a Bayesian Exponential Mixture model.  <a href="#a32ca3b7795cfca37cae992679f3941e4">More...</a><br /></td></tr>
<tr class="separator:a32ca3b7795cfca37cae992679f3941e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add48ca85024ae3b0aafc6e30e684e487"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#add48ca85024ae3b0aafc6e30e684e487">learnGMC</a> (const <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;X, <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;qZ, std::vector&lt; <a class="el" href="classdistributions_1_1_g_dirichlet.html">distributions::GDirichlet</a> &gt; &amp;weights, std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;clusters, const double clusterprior=<a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a>, const int maxclusters=-1, const bool sparse=false, const bool verbose=false, const unsigned int nthreads=omp_get_max_threads())</td></tr>
<tr class="memdesc:add48ca85024ae3b0aafc6e30e684e487"><td class="mdescLeft">&#160;</td><td class="mdescRight">The learning algorithm for the Groups of Mixtures Clustering model.  <a href="#add48ca85024ae3b0aafc6e30e684e487">More...</a><br /></td></tr>
<tr class="separator:add48ca85024ae3b0aafc6e30e684e487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ac21ec19acdb6f251a635c41eda741"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#ae6ac21ec19acdb6f251a635c41eda741">learnSGMC</a> (const <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;X, <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;qZ, std::vector&lt; <a class="el" href="classdistributions_1_1_dirichlet.html">distributions::Dirichlet</a> &gt; &amp;weights, std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;clusters, const double clusterprior=<a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a>, const int maxclusters=-1, const bool sparse=false, const bool verbose=false, const unsigned int nthreads=omp_get_max_threads())</td></tr>
<tr class="memdesc:ae6ac21ec19acdb6f251a635c41eda741"><td class="mdescLeft">&#160;</td><td class="mdescRight">The learning algorithm for the Symmetric Groups of Mixtures Clustering model. The is referred to as <em>Gaussian Latent Dirichlet Allocation</em> (G-LDA) in [3, 4].  <a href="#ae6ac21ec19acdb6f251a635c41eda741">More...</a><br /></td></tr>
<tr class="separator:ae6ac21ec19acdb6f251a635c41eda741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86192bbfa5f2fcf4e2743919f76e3dd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#af86192bbfa5f2fcf4e2743919f76e3dd">learnDGMC</a> (const <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;X, <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;qZ, std::vector&lt; <a class="el" href="classdistributions_1_1_g_dirichlet.html">distributions::GDirichlet</a> &gt; &amp;weights, std::vector&lt; <a class="el" href="classdistributions_1_1_norm_gamma.html">distributions::NormGamma</a> &gt; &amp;clusters, const double clusterprior=<a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a>, const int maxclusters=-1, const bool sparse=false, const bool verbose=false, const unsigned int nthreads=omp_get_max_threads())</td></tr>
<tr class="memdesc:af86192bbfa5f2fcf4e2743919f76e3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The learning algorithm for the Groups of Mixtures Clustering model but with diagonal covariance Gaussians.  <a href="#af86192bbfa5f2fcf4e2743919f76e3dd">More...</a><br /></td></tr>
<tr class="separator:af86192bbfa5f2fcf4e2743919f76e3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1121ca5ec060547d6a7b123cc57c430e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#a1121ca5ec060547d6a7b123cc57c430e">learnEGMC</a> (const <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;X, <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;qZ, std::vector&lt; <a class="el" href="classdistributions_1_1_g_dirichlet.html">distributions::GDirichlet</a> &gt; &amp;weights, std::vector&lt; <a class="el" href="classdistributions_1_1_exp_gamma.html">distributions::ExpGamma</a> &gt; &amp;clusters, const double clusterprior=<a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a>, const int maxclusters=-1, const bool sparse=false, const bool verbose=false, const unsigned int nthreads=omp_get_max_threads())</td></tr>
<tr class="memdesc:a1121ca5ec060547d6a7b123cc57c430e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The learning algorithm for the Exponential Groups of Mixtures Clustering model.  <a href="#a1121ca5ec060547d6a7b123cc57c430e">More...</a><br /></td></tr>
<tr class="separator:a1121ca5ec060547d6a7b123cc57c430e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc291b12cd7da6fbc75787071838f1a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#a5dc291b12cd7da6fbc75787071838f1a">learnSCM</a> (const <a class="el" href="namespacelibcluster.html#a59610bea91daa45fe7c8e3781e467148">vvMatrixXd</a> &amp;X, <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;qY, <a class="el" href="namespacelibcluster.html#a59610bea91daa45fe7c8e3781e467148">vvMatrixXd</a> &amp;qZ, std::vector&lt; <a class="el" href="classdistributions_1_1_g_dirichlet.html">distributions::GDirichlet</a> &gt; &amp;weights_j, std::vector&lt; <a class="el" href="classdistributions_1_1_dirichlet.html">distributions::Dirichlet</a> &gt; &amp;weights_t, std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;clusters, const double dirprior=<a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a>, const double gausprior=<a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a>, const unsigned int maxT=<a class="el" href="namespacelibcluster.html#a8d48ba20b3e076215059d8b3c789884a">TRUNC</a>, const int maxK=-1, const bool verbose=false, const unsigned int nthreads=omp_get_max_threads())</td></tr>
<tr class="memdesc:a5dc291b12cd7da6fbc75787071838f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The learning algorithm for the "Simultaneous Clustering Model".  <a href="#a5dc291b12cd7da6fbc75787071838f1a">More...</a><br /></td></tr>
<tr class="separator:a5dc291b12cd7da6fbc75787071838f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183cec6161641bb2d30966dd1a54e8ea"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#a183cec6161641bb2d30966dd1a54e8ea">learnMCM</a> (const <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;W, const <a class="el" href="namespacelibcluster.html#a59610bea91daa45fe7c8e3781e467148">vvMatrixXd</a> &amp;X, <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;qY, <a class="el" href="namespacelibcluster.html#a59610bea91daa45fe7c8e3781e467148">vvMatrixXd</a> &amp;qZ, std::vector&lt; <a class="el" href="classdistributions_1_1_g_dirichlet.html">distributions::GDirichlet</a> &gt; &amp;weights_j, std::vector&lt; <a class="el" href="classdistributions_1_1_dirichlet.html">distributions::Dirichlet</a> &gt; &amp;weights_t, std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;clusters_t, std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;clusters_k, const double prior_t=<a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a>, const double prior_k=<a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a>, const unsigned int maxT=<a class="el" href="namespacelibcluster.html#a8d48ba20b3e076215059d8b3c789884a">TRUNC</a>, const int maxK=-1, const bool verbose=false, const unsigned int nthreads=omp_get_max_threads())</td></tr>
<tr class="memdesc:a183cec6161641bb2d30966dd1a54e8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The learning algorithm for the "Multiple-source Clustering Model".  <a href="#a183cec6161641bb2d30966dd1a54e8ea">More...</a><br /></td></tr>
<tr class="separator:a183cec6161641bb2d30966dd1a54e8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5e7e1941333a35261df3fa4d7305c22e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e7e1941333a35261df3fa4d7305c22e"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a> = 1.0</td></tr>
<tr class="memdesc:a5e7e1941333a35261df3fa4d7305c22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default prior hyperparameter value. <br /></td></tr>
<tr class="separator:a5e7e1941333a35261df3fa4d7305c22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d48ba20b3e076215059d8b3c789884a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d48ba20b3e076215059d8b3c789884a"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#a8d48ba20b3e076215059d8b3c789884a">TRUNC</a> = 100</td></tr>
<tr class="memdesc:a8d48ba20b3e076215059d8b3c789884a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncation level for classes. <br /></td></tr>
<tr class="separator:a8d48ba20b3e076215059d8b3c789884a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523f177b0ea5a394cad7171b6cfd2c37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a523f177b0ea5a394cad7171b6cfd2c37"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#a523f177b0ea5a394cad7171b6cfd2c37">SPLITITER</a> = 15</td></tr>
<tr class="memdesc:a523f177b0ea5a394cad7171b6cfd2c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Max number of iter. for split VBEM. <br /></td></tr>
<tr class="separator:a523f177b0ea5a394cad7171b6cfd2c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae241be513b30347d8bf57642f4982190"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae241be513b30347d8bf57642f4982190"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#ae241be513b30347d8bf57642f4982190">CONVERGE</a> = 1e-5f</td></tr>
<tr class="memdesc:ae241be513b30347d8bf57642f4982190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convergence threshold. <br /></td></tr>
<tr class="separator:ae241be513b30347d8bf57642f4982190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae160957d99bf0c82fe658a69c85ac6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ae160957d99bf0c82fe658a69c85ac6"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#a9ae160957d99bf0c82fe658a69c85ac6">FENGYDEL</a> = <a class="el" href="namespacelibcluster.html#ae241be513b30347d8bf57642f4982190">CONVERGE</a>/10</td></tr>
<tr class="memdesc:a9ae160957d99bf0c82fe658a69c85ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allowance for +ve F.E. steps. <br /></td></tr>
<tr class="separator:a9ae160957d99bf0c82fe658a69c85ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229bf6f2ae6de5fbf2bb64b2adc9857a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a229bf6f2ae6de5fbf2bb64b2adc9857a"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelibcluster.html#a229bf6f2ae6de5fbf2bb64b2adc9857a">ZEROCUTOFF</a> = 0.1f</td></tr>
<tr class="memdesc:a229bf6f2ae6de5fbf2bb64b2adc9857a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obs. count cut off sparse updates. <br /></td></tr>
<tr class="separator:a229bf6f2ae6de5fbf2bb64b2adc9857a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace that contains implementations of Bayesian mixture model based algorithms for clustering. </p>
<p>This namespace provides various Bayesian mixture models that can be used for clustering data. The algorithms that have been implemented are:</p>
<ul>
<li>Variational Dirichlet Process (VDP) for Gaussian observations [1, 6], see <a class="el" href="namespacelibcluster.html#a0fbb77cd8728a6fc433153eddedea0ce" title="The learning algorithm for the Variational Dirichlet Process for Gaussian clusters. ">learnVDP()</a>.</li>
<li>The Bayesian Gaussian Mixture model [7] ch 11, see <a class="el" href="namespacelibcluster.html#adf8a1e813c9b99a64d25e0edca9eabc1" title="The learning algorithm for a Bayesian Gaussian Mixture model. ">learnBGMM()</a>.</li>
<li>The Bayesian Gaussian Mixture model with diagonal covariance Gaussians, see <a class="el" href="namespacelibcluster.html#af6eaa1e8eca76f44ee1beb02a12681c5" title="The learning algorithm for a Bayesian Gaussian Mixture model with diagonal covariance matrices...">learnDGMM()</a>.</li>
<li>Bayesian Exponential Mixture model with a Gamma prior, see <a class="el" href="namespacelibcluster.html#a32ca3b7795cfca37cae992679f3941e4" title="The learning algorithm for a Bayesian Exponential Mixture model. ">learnBEMM()</a>.</li>
<li>Groups of Mixtures Clustering (GMC) model for Gaussian observations [4], see <a class="el" href="namespacelibcluster.html#add48ca85024ae3b0aafc6e30e684e487" title="The learning algorithm for the Groups of Mixtures Clustering model. ">learnGMC()</a>.</li>
<li>Symmetric Groups of Mixtures Clustering (S-GMC) model for Gaussian observations [5], see <a class="el" href="namespacelibcluster.html#ae6ac21ec19acdb6f251a635c41eda741" title="The learning algorithm for the Symmetric Groups of Mixtures Clustering model. The is referred to as G...">learnSGMC()</a>. This is referred to as Gaussian Latent Dirichlet Allocation (G-LDA) in [3, 4].</li>
<li>Groups of Mixtures Clustering model for diagonal covariance Gaussian observations, see <a class="el" href="namespacelibcluster.html#af86192bbfa5f2fcf4e2743919f76e3dd" title="The learning algorithm for the Groups of Mixtures Clustering model but with diagonal covariance Gauss...">learnDGMC()</a>.</li>
<li>Groups of Mixtures Clustering model for Exponential observations, see <a class="el" href="namespacelibcluster.html#a1121ca5ec060547d6a7b123cc57c430e" title="The learning algorithm for the Exponential Groups of Mixtures Clustering model. ">learnEGMC()</a>.</li>
<li>Simultaneous Clustering Model (SCM) for Multinomial Documents, and Gaussian Observations, see <a class="el" href="namespacelibcluster.html#a5dc291b12cd7da6fbc75787071838f1a" title="The learning algorithm for the &quot;Simultaneous Clustering Model&quot;. ">learnSCM()</a> and [4, 5].</li>
<li>Multiple-source Clustering Model (MCM) for clustering two observations, one of an image/document, and multiple of segments/words simultaneously, see <a class="el" href="namespacelibcluster.html#a183cec6161641bb2d30966dd1a54e8ea" title="The learning algorithm for the &quot;Multiple-source Clustering Model&quot;. ">learnMCM()</a> and [3, 4, 5].</li>
<li>A myriad of other algorithms are possible, but have not been enumerated in the interfaces here.</li>
</ul>
<p>All of these algorithms infer the number of clusters present in the data.</p>
<p>[1] K. Kurihara, M. Welling, and N. Vlassis, Accelerated variational Dirichlet process mixtures. Advances in Neural Information Processing Systems, vol. 19, p. 761, 2007.</p>
<p>[2] Y. Teh, K. Kurihara, and M. Welling. Collapsed variational inference for HDP. Advances in Neural Information Processing Systems, 20:1481–1488, 2008.</p>
<p>[3] D. M. Steinberg, O. Pizarro, S. B. Williams. Synergistic Clustering of Image and Segment Descriptors for Unsupervised Scene Understanding. In International Conference on Computer Vision (ICCV). IEEE, Sydney, NSW, 2013.</p>
<p>[4] D. M. Steinberg, O. Pizarro, S. B. Williams. Hierarchical Bayesian Models for Unsupervised Scene Understanding. Journal of Computer Vision and Image Understanding (CVIU). Elsevier, 2014.</p>
<p>[5] D. M. Steinberg, An Unsupervised Approach to Modelling Visual Data, PhD Thesis, 2013.</p>
<p>[6] D. M. Steinberg, A. Friedman, O. Pizarro, and S. B. Williams. A Bayesian nonparametric approach to clustering data from underwater robotic surveys. In International Symposium on Robotics Research, Flagstaff, AZ, Aug. 2011.</p>
<p>[7] C. M. Bishop, Pattern Recognition and Machine Learning. Cambridge, UK: Springer Science+Business Media, 2006.</p>
<dl class="section note"><dt>Note</dt><dd>The greedy cluster splitting heuristic is different from that presented in [1] in that it is much faster, but may not choose the "best" cluster to split first.</dd>
<dd>
The code is generic enough to allow new clustering algorithms to be implemented quickly, since all of the algorithms use templated distribution types.</dd></dl>
<dl class="section author"><dt>Author</dt><dd>Daniel Steinberg Australian Centre for Field Robotics The University of Sydney</dd></dl>
<dl class="section date"><dt>Date</dt><dd>20/10/2013</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd><p class="startdd">Find a better way to parallelise the vanilla clustering algorithms. </p>
<p>Make this library more generic so discrete distributions can be used? </p>
<p class="enddd">Should probably get rid of all the vector copies in splitting functions and interface functions. </p>
</dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a32ca3b7795cfca37cae992679f3941e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double libcluster::learnBEMM </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>qZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdistributions_1_1_dirichlet.html">distributions::Dirichlet</a> &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_exp_gamma.html">distributions::ExpGamma</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>clusterprior</em> = <code><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxclusters</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>omp_get_max_threads()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The learning algorithm for a Bayesian Exponential Mixture model. </p>
<p>This function implements a Bayesian Exponential mixture model clustering algorithm. The Exponential mixture model uses a Dirichlet prior on the mixture weights, but an Exponential cluster distribution (with a Gamma prior). Each dimension of the data is assumed independent i.e. this is a Naive-Bayes assumption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the observation matrix, NxD where N is the number of observations, and D is the number of dimensions. X MUST be in the range [0, inf). </td></tr>
    <tr><td class="paramname">qZ</td><td>is an NxK matrix of the variational posterior approximation to p(Z|X). This will always be overwritten to start with one cluster. </td></tr>
    <tr><td class="paramname">weights</td><td>is the distributions over the mixture weights of the model. </td></tr>
    <tr><td class="paramname">clusters</td><td>is a vector of distributions over the cluster parameters of the model, this will be size K. </td></tr>
    <tr><td class="paramname">clusterprior</td><td>is the prior 'tuning' parameter for the cluster parameter distributions. This effects how many clusters will be found. </td></tr>
    <tr><td class="paramname">maxclusters</td><td>is the maximum number of clusters to search for, -1 (default) means no upper bound. </td></tr>
    <tr><td class="paramname">verbose</td><td>flag for triggering algorithm status messages. Default is 0 = silent. </td></tr>
    <tr><td class="paramname">nthreads</td><td>sets the number of threads for the clustering algorithm to use. The group cluster algorithms take fuller advantage of this. The default value is automatically determined by OpenMP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Final free energy </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are invalid argument calls. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if there are runtime issues with the VDP algorithm such as negative free energy steps, unexpected empty clusters etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf8a1e813c9b99a64d25e0edca9eabc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double libcluster::learnBGMM </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>qZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdistributions_1_1_dirichlet.html">distributions::Dirichlet</a> &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>clusterprior</em> = <code><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxclusters</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>omp_get_max_threads()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The learning algorithm for a Bayesian Gaussian Mixture model. </p>
<p>This function implements the Bayesian GMM clustering algorithm as specified by [1]. In practice I have found this performs almost identically to the VDP, especially for large data cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the observation matrix, NxD where N is the number of observations, and D is the number of dimensions. </td></tr>
    <tr><td class="paramname">qZ</td><td>is an NxK matrix of the variational posterior approximation to p(Z|X). This will always be overwritten to start with one cluster. </td></tr>
    <tr><td class="paramname">weights</td><td>is the distributions over the mixture weights of the model. </td></tr>
    <tr><td class="paramname">clusters</td><td>is a vector of distributions over the cluster parameters of the model, this will be size K. </td></tr>
    <tr><td class="paramname">clusterprior</td><td>is the prior 'tuning' parameter for the cluster parameter distributions. This effects how many clusters will be found. </td></tr>
    <tr><td class="paramname">verbose</td><td>flag for triggering algorithm status messages. Default is 0 = silent. </td></tr>
    <tr><td class="paramname">nthreads</td><td>sets the number of threads for the clustering algorithm to use. The group cluster algorithms take fuller advantage of this. The default value is automatically determined by OpenMP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Final free energy </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are invalid argument calls such as non-PSD matrix calculations. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if there are runtime issues with the VDP algorithm such as negative free energy steps, unexpected empty clusters etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af86192bbfa5f2fcf4e2743919f76e3dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double libcluster::learnDGMC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>qZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_g_dirichlet.html">distributions::GDirichlet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_norm_gamma.html">distributions::NormGamma</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>clusterprior</em> = <code><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxclusters</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sparse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>omp_get_max_threads()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The learning algorithm for the Groups of Mixtures Clustering model but with diagonal covariance Gaussians. </p>
<p>This function implements the Groups of Mixtues Clustering model algorithm as specified by [5], with the additional "sparse" option but with diagonal covariance Gaussians, i.e. this is a Naive-Bayes assumption. The DGMC uses a Generalised Dirichlet prior on the group mixture weights and Normal cluster distributions (With Normal-Gamma priors). This algorithm is similar to a one-level Hierarchical Dirichlet process with Gaussian observations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the observation matrices. Vector of N_jxD matrices where N_j is the number of observations in each group, j, and D is the number of dimensions. </td></tr>
    <tr><td class="paramname">qZ</td><td>is a vector of N_jxK matrices of the variational posterior approximations to p(z_j|X_j). K is the number of model clusters. This will always be overwritten to start with one cluster. </td></tr>
    <tr><td class="paramname">weights</td><td>is a vector of distributions over the mixture weights of the model, for each group of data, J. </td></tr>
    <tr><td class="paramname">clusters</td><td>is a vector of distributions over the cluster parameters of the model, this will be size K. </td></tr>
    <tr><td class="paramname">clusterprior</td><td>is the prior 'tuning' parameter for the cluster parameter distributions. This effects how many clusters will be found. </td></tr>
    <tr><td class="paramname">maxclusters</td><td>is the maximum number of clusters to search for, -1 (default) means no upper bound. </td></tr>
    <tr><td class="paramname">sparse</td><td>flag for enabling the "sparse" updates for the GMC. Some small amount of accuracy is traded off for a potentially large speed increase by not updating zero group weight cluster observation likelihoods. By default this is not enabled. </td></tr>
    <tr><td class="paramname">verbose</td><td>flag for triggering algorithm status messages. Default is 0 = silent. </td></tr>
    <tr><td class="paramname">nthreads</td><td>sets the number of threads for the clustering algorithm to use. The default value is automatically determined by OpenMP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Final free energy </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are invalid argument calls such as negative diagonal covariance matrix calculations. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if there are runtime issues with the GMC algorithm such as negative free energy steps, unexpected empty clusters etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6eaa1e8eca76f44ee1beb02a12681c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double libcluster::learnDGMM </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>qZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdistributions_1_1_dirichlet.html">distributions::Dirichlet</a> &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_norm_gamma.html">distributions::NormGamma</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>clusterprior</em> = <code><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxclusters</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>omp_get_max_threads()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The learning algorithm for a Bayesian Gaussian Mixture model with diagonal covariance matrices. </p>
<p>This function implements the Bayesian GMM clustering algorithm as specified by [1] but with diagonal covariance matrices, i.e. this is a Naive-Bayes assumption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the observation matrix, NxD where N is the number of observations, and D is the number of dimensions. </td></tr>
    <tr><td class="paramname">qZ</td><td>is an NxK matrix of the variational posterior approximation to p(Z|X). This will always be overwritten to start with one cluster. </td></tr>
    <tr><td class="paramname">weights</td><td>is the distributions over the mixture weights of the model. </td></tr>
    <tr><td class="paramname">clusters</td><td>is a vector of distributions over the cluster parameters of the model, this will be size K. </td></tr>
    <tr><td class="paramname">clusterprior</td><td>is the prior 'tuning' parameter for the cluster parameter distributions. This effects how many clusters will be found. </td></tr>
    <tr><td class="paramname">maxclusters</td><td>is the maximum number of clusters to search for, -1 (default) means no upper bound. </td></tr>
    <tr><td class="paramname">verbose</td><td>flag for triggering algorithm status messages. Default is 0 = silent. </td></tr>
    <tr><td class="paramname">nthreads</td><td>sets the number of threads for the clustering algorithm to use. The group cluster algorithms take fuller advantage of this. The default value is automatically determined by OpenMP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Final free energy </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are invalid argument calls such as negative diagonal covariance matrix calculations. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if there are runtime issues with the VDP algorithm such as negative free energy steps, unexpected empty clusters etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1121ca5ec060547d6a7b123cc57c430e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double libcluster::learnEGMC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>qZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_g_dirichlet.html">distributions::GDirichlet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_exp_gamma.html">distributions::ExpGamma</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>clusterprior</em> = <code><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxclusters</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sparse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>omp_get_max_threads()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The learning algorithm for the Exponential Groups of Mixtures Clustering model. </p>
<p>This function implements the Exponential Groups of Mixtures Clustering model, with the additional "sparse" option. The Exponential GMC uses a Generalised Dirichlet prior on the group mixture weights, but an Exponential cluster distribution (with a Gamma prior). This algorithm is similar to a one-level Hierarchical Dirichlet process with Exponential observations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the observation matrices. Vector of N_jxD matrices where N_j is the number of observations in each group, j, and D is the number of dimensions. X MUST be in the range [0, inf). </td></tr>
    <tr><td class="paramname">qZ</td><td>is a vector of N_jxK matrices of the variational posterior approximations to p(z_j|X_j). K is the number of model clusters. This will always be overwritten to start with one cluster. </td></tr>
    <tr><td class="paramname">weights</td><td>is a vector of distributions over the mixture weights of the model, for each group of data, J. </td></tr>
    <tr><td class="paramname">clusters</td><td>is a vector of distributions over the cluster parameters of the model, this will be size K. </td></tr>
    <tr><td class="paramname">clusterprior</td><td>is the prior 'tuning' parameter for the cluster parameter distributions. This effects how many clusters will be found. </td></tr>
    <tr><td class="paramname">maxclusters</td><td>is the maximum number of clusters to search for, -1 (default) means no upper bound. </td></tr>
    <tr><td class="paramname">sparse</td><td>flag for enabling the "sparse" updates for the GMC. Some small amount of accuracy is traded off for a potentially large speed increase by not updating zero group weight cluster observation likelihoods. By default this is not enabled. </td></tr>
    <tr><td class="paramname">verbose</td><td>flag for triggering algorithm status messages. Default is 0 = silent. </td></tr>
    <tr><td class="paramname">nthreads</td><td>sets the number of threads for the clustering algorithm to use. The default value is automatically determined by OpenMP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Final free energy </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are invalid argument calls. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if there are runtime issues with the GMC algorithm such as negative free energy steps, unexpected empty clusters etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add48ca85024ae3b0aafc6e30e684e487"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double libcluster::learnGMC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>qZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_g_dirichlet.html">distributions::GDirichlet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>clusterprior</em> = <code><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxclusters</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sparse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>omp_get_max_threads()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The learning algorithm for the Groups of Mixtures Clustering model. </p>
<p>This function implements the Groups of Mixtues Clustering model algorithm as specified by [4], with the additional "sparse" option. The GMC uses a Generalised Dirichlet prior on the group mixture weights and Gaussian cluster distributions (With Gausian-Wishart priors). This algorithm is similar to a one-level Hierarchical Dirichlet process with Gaussian observations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the observation matrices. Vector of N_jxD matrices where N_j is the number of observations in each group, j, and D is the number of dimensions. </td></tr>
    <tr><td class="paramname">qZ</td><td>is a vector of N_jxK matrices of the variational posterior approximations to p(z_j|X_j). K is the number of model clusters. This will always be overwritten to start with one cluster. </td></tr>
    <tr><td class="paramname">weights</td><td>is a vector of distributions over the mixture weights of the model, for each group of data, J. </td></tr>
    <tr><td class="paramname">clusters</td><td>is a vector of distributions over the cluster parameters of the model, this will be size K. </td></tr>
    <tr><td class="paramname">clusterprior</td><td>is the prior 'tuning' parameter for the cluster parameter distributions. This effects how many clusters will be found. </td></tr>
    <tr><td class="paramname">maxclusters</td><td>is the maximum number of clusters to search for, -1 (default) means no upper bound. </td></tr>
    <tr><td class="paramname">sparse</td><td>flag for enabling the "sparse" updates for the GMC. Some small amount of accuracy is traded off for a potentially large speed increase by not updating zero group weight cluster observation likelihoods. By default this is not enabled. </td></tr>
    <tr><td class="paramname">verbose</td><td>flag for triggering algorithm status messages. Default is 0 = silent. </td></tr>
    <tr><td class="paramname">nthreads</td><td>sets the number of threads for the clustering algorithm to use. The default value is automatically determined by OpenMP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Final free energy </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are invalid argument calls such as non-PSD matrix calculations. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if there are runtime issues with the GMC algorithm such as negative free energy steps, unexpected empty clusters etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a183cec6161641bb2d30966dd1a54e8ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double libcluster::learnMCM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacelibcluster.html#a59610bea91daa45fe7c8e3781e467148">vvMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>qY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibcluster.html#a59610bea91daa45fe7c8e3781e467148">vvMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>qZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_g_dirichlet.html">distributions::GDirichlet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_dirichlet.html">distributions::Dirichlet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters_k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>prior_t</em> = <code><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>prior_k</em> = <code><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>maxT</em> = <code><a class="el" href="namespacelibcluster.html#a8d48ba20b3e076215059d8b3c789884a">TRUNC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxK</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>omp_get_max_threads()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The learning algorithm for the "Multiple-source Clustering Model". </p>
<p>This function implements the "Multiple-source Clustering Model" algorithm as specified by [3 - 5]. This model jointly cluster both "document" level observations, and "word" observations. The MCM uses a Generalised Dirichlet prior on the group mixture weights, Multinomial-Gaussian top-level (document) clusters, and Gaussian bottom-level (word) cluster distributions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">W</td><td>the top-level observation matrices. Vector of length J with N_jxDt matrices where N_j is the number of observations in each group, j, and Dt is the number of dimensions. J is the total number of groups. </td></tr>
    <tr><td class="paramname">X</td><td>the bottom-level observation matrices. A vector of length J (for each group), of vectors of length I_j (for each image or "document") of N_jixDb matrices. Here N_ji is the number of observations in each document, I_j, in group, j, and Db is the number of dimensions. </td></tr>
    <tr><td class="paramname">qY</td><td>the probabilistic label of documents/images to top-level clusters. It is a vector of length J (for each group), of I_jxT matrices of the soft assignments of each document/image (i) to a cluster label (t). It is the variational posterior to p(y_j|Z_j). This is randomly initialised, and uses the parameter T for max number of classes. </td></tr>
    <tr><td class="paramname">qZ</td><td>the probabilistic label of observations to bottom-level clusters. It is a vector of length J (for each group), of vectors of length I_j (for each "document") of N_jixK matrices of the variational posterior approximations to p(z_ji|X_ji). K is the number of bottom-level clusters. This will always be overwritten to start with one cluster. </td></tr>
    <tr><td class="paramname">weights_j</td><td>is a vector of distributions over the weights of top-level cluster mixtures of the model, for each group of data, J, like the GMC. </td></tr>
    <tr><td class="paramname">weights_t</td><td>is a vector of distributions over the weights that partially parameterise the top-level clusters. These also parameterise the distribution of the bottom-level cluster weights &ndash; this will be of size T* (see parameter T). </td></tr>
    <tr><td class="paramname">clusters_t</td><td>is a vector of distributions over the top-level clusters parameters of the model (corresponding to W), this will be size T*. </td></tr>
    <tr><td class="paramname">clusters_k</td><td>is a vector of distributions over the bottom-level cluster parameters of the model (corresponding to X), this will be size K. </td></tr>
    <tr><td class="paramname">prior_t</td><td>is the prior 'tuning' parameter for the top-level (Gaussian) cluster parameter distributions (W). This effects how many top level clusters will be found. </td></tr>
    <tr><td class="paramname">prior_k</td><td>is the prior 'tuning' parameter for the bottom-level cluster parameter distributions (X). This effects how many bottom-level clusters will be found. </td></tr>
    <tr><td class="paramname">maxT</td><td>the maximum number of top-level clusters to look for. Usually, if maxT is set large, T* &lt; maxT top-level clusters will be found. </td></tr>
    <tr><td class="paramname">maxK</td><td>is the maximum number of bottom level clusters to search for, -1 (default) means no upper bound. </td></tr>
    <tr><td class="paramname">verbose</td><td>flag for triggering algorithm status messages. Default is 0 = silent. </td></tr>
    <tr><td class="paramname">nthreads</td><td>sets the number of threads for the clustering algorithm to use. The default value is automatically determined by OpenMP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Final free energy </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are invalid argument calls such as non-PSD matrix calculations. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if there are runtime issues with the GMC algorithm such as negative free energy steps, unexpected empty clusters etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5dc291b12cd7da6fbc75787071838f1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double libcluster::learnSCM </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelibcluster.html#a59610bea91daa45fe7c8e3781e467148">vvMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>qY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibcluster.html#a59610bea91daa45fe7c8e3781e467148">vvMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>qZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_g_dirichlet.html">distributions::GDirichlet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_dirichlet.html">distributions::Dirichlet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dirprior</em> = <code><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>gausprior</em> = <code><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>maxT</em> = <code><a class="el" href="namespacelibcluster.html#a8d48ba20b3e076215059d8b3c789884a">TRUNC</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxK</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>omp_get_max_threads()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The learning algorithm for the "Simultaneous Clustering Model". </p>
<p>This function implements the "Simultaneous Clustering Model" algorithm as specified by [4, 5]. The SCM uses a Generalised Dirichlet prior on the group mixture weights, a Dirichlet prior on the top-level clusters and Gaussian bottom-level cluster distributions for observations (with Gausian-Wishart priors).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the observation matrices. A vector of length J (for each group), of vectors of length I_j (for each image/document etc) of N_jixD matrices. Here N_ji is the number of observations in each document, I_j, in group, j, and D is the number of dimensions. </td></tr>
    <tr><td class="paramname">qY</td><td>the probabilistic label of documents/images to top-level clusters. It is a vector of length J (for each group), of I_jxT matrices of the soft assignments of each document/image (i) to a cluster label (t). It is the variational posterior to p(y_j|Z_j). This is randomly initialised, and uses the parameter T for max number of classes. </td></tr>
    <tr><td class="paramname">qZ</td><td>the probabilistic label of observations to bottom-level clusters. It is a vector of length J (for each group), of vectors of length I_j (for each "document") of N_jixK matrices of the variational posterior approximations to p(z_ji|X_ji). K is the number of bottom-level clusters. This will always be overwritten to start with one cluster. </td></tr>
    <tr><td class="paramname">weights_j</td><td>is a vector of distributions over the weights of top-level cluster mixtures of the model, for each group of data, J, like the GMC. </td></tr>
    <tr><td class="paramname">weights_t</td><td>is a vector of distributions over the weights that parameterise the top-level clusters. These also parameterise the distribution of the bottom-level cluster weights &ndash; this will be of size T* (see parameter T). </td></tr>
    <tr><td class="paramname">clusters</td><td>is a vector of distributions over the segment cluster parameters of the model, this will be size K. </td></tr>
    <tr><td class="paramname">dirprior</td><td>is the prior 'tuning' parameter for the top-level dirichlet cluster parameter distributions. This effects how many top-level clusters will be found. </td></tr>
    <tr><td class="paramname">gausprior</td><td>is the prior 'tuning' parameter for the bottom-level Gaussian cluster parameter distributions. This effects how many clusters will be found. </td></tr>
    <tr><td class="paramname">maxT</td><td>the maximum number of top-level clusters to look for. Usually, if maxT is set large, T* &lt; maxT top-level clusters will be found. </td></tr>
    <tr><td class="paramname">maxK</td><td>is the maximum number of bottom level clusters to search for, -1 (default) means no upper bound. </td></tr>
    <tr><td class="paramname">verbose</td><td>flag for triggering algorithm status messages. Default is 0 = silent. </td></tr>
    <tr><td class="paramname">nthreads</td><td>sets the number of threads for the clustering algorithm to use. The default value is automatically determined by OpenMP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Final free energy </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are invalid argument calls such as non-PSD matrix calculations. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if there are runtime issues with the GMC algorithm such as negative free energy steps, unexpected empty clusters etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6ac21ec19acdb6f251a635c41eda741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double libcluster::learnSGMC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacelibcluster.html#a3e50a4ac1b9e897150bb3b66d3dbf1e7">vMatrixXd</a> &amp;&#160;</td>
          <td class="paramname"><em>qZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_dirichlet.html">distributions::Dirichlet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>clusterprior</em> = <code><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxclusters</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>sparse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>omp_get_max_threads()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The learning algorithm for the Symmetric Groups of Mixtures Clustering model. The is referred to as <em>Gaussian Latent Dirichlet Allocation</em> (G-LDA) in [3, 4]. </p>
<p>This function implements the Symmetric Groups of Mixtures Clustering model as specified by [4, 5], with the additional "sparse" option. The Symmetric GMC uses a symmetric Dirichlet prior on the group mixture weights and Gaussian cluster distributions (With Gausian-Wishart priors). This algorithm is similar to latent Dirichlet allocation with Gaussian observations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the observation matrices. Vector of N_jxD matrices where N_j is the number of observations in each group, j, and D is the number of dimensions. </td></tr>
    <tr><td class="paramname">qZ</td><td>is a vector of N_jxK matrices of the variational posterior approximations to p(z_j|X_j). K is the number of model clusters. This will always be overwritten to start with one cluster. </td></tr>
    <tr><td class="paramname">weights</td><td>is a vector of distributions over the mixture weights of the model, for each group of data, J. </td></tr>
    <tr><td class="paramname">clusters</td><td>is a vector of distributions over the cluster parameters of the model, this will be size K. </td></tr>
    <tr><td class="paramname">clusterprior</td><td>is the prior 'tuning' parameter for the cluster parameter distributions. This effects how many clusters will be found. </td></tr>
    <tr><td class="paramname">maxclusters</td><td>is the maximum number of clusters to search for, -1 (default) means no upper bound. </td></tr>
    <tr><td class="paramname">sparse</td><td>flag for enabling the "sparse" updates for the GMC. Some small amount of accuracy is traded off for a potentially large speed increase by not updating zero group weight cluster observation likelihoods. By default this is not enabled. </td></tr>
    <tr><td class="paramname">verbose</td><td>flag for triggering algorithm status messages. Default is 0 = silent. </td></tr>
    <tr><td class="paramname">nthreads</td><td>sets the number of threads for the clustering algorithm to use. The default value is automatically determined by OpenMP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Final free energy </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are invalid argument calls such as non-PSD matrix calculations. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if there are runtime issues with the GMC algorithm such as negative free energy steps, unexpected empty clusters etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fbb77cd8728a6fc433153eddedea0ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double libcluster::learnVDP </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>qZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdistributions_1_1_stick_break.html">distributions::StickBreak</a> &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classdistributions_1_1_gauss_wish.html">distributions::GaussWish</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clusters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>clusterprior</em> = <code><a class="el" href="namespacelibcluster.html#a5e7e1941333a35261df3fa4d7305c22e">PRIORVAL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>maxclusters</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>nthreads</em> = <code>omp_get_max_threads()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The learning algorithm for the Variational Dirichlet Process for Gaussian clusters. </p>
<p>This function implements the VDP clustering algorithm as specified by [1], however a different 'nesting' strategy is used. The nesting strategy sets all q(z_n &gt; K) = 0, rather than setting the parameter distributions equal to their priors over this truncation bound, K. This is the same nesting strategy as used in [2]. This is also used in [3-5].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">X</td><td>the observation matrix, NxD where N is the number of observations, and D is the number of dimensions. </td></tr>
    <tr><td class="paramname">qZ</td><td>is an NxK matrix of the variational posterior approximation to p(Z|X). This will always be overwritten to start with one cluster. </td></tr>
    <tr><td class="paramname">weights</td><td>is the distributions over the mixture weights of the model. </td></tr>
    <tr><td class="paramname">clusters</td><td>is a vector of distributions over the cluster parameters of the model, this will be size K. </td></tr>
    <tr><td class="paramname">clusterprior</td><td>is the prior 'tuning' parameter for the cluster parameter distributions. This effects how many clusters will be found. </td></tr>
    <tr><td class="paramname">verbose</td><td>flag for triggering algorithm status messages. Default is 0 = silent. </td></tr>
    <tr><td class="paramname">nthreads</td><td>sets the number of threads for the clustering algorithm to use. The group cluster algorithms take fuller advantage of this. The default value is automatically determined by OpenMP. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Final free energy </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>if there are invalid argument calls such as non-PSD matrix calculations. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if there are runtime issues with the VDP algorithm such as negative free energy steps, unexpected empty clusters etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelibcluster.html">libcluster</a></li>
    <li class="footer">Generated on Mon Jun 12 2017 13:17:38 for libcluster by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
